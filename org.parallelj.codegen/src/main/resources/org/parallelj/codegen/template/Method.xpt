«IMPORT parallelj»
«EXTENSION org::parallelj::codegen::extensions::common»


«DEFINE constructor FOR Program»
«REM»
	/**
	 * Empty Constructor  
	 */
	 «EXPAND Annotation::generated FOR this»
	 public «this.getProgramName()» (){
	 }
«ENDREM»
«ENDDEFINE»

 
«DEFINE procedure FOR Element»
	«IF this.metaType == Handler -»
		«EXPAND Method::handler FOR (Handler)this -»
	«ELSEIF this.metaType == Pipeline -»
		«EXPAND Method::pipeline FOR (Pipeline)this -»
	«ELSE-»
		«IF this.metaType.isAssignableFrom(Procedure) || this.metaType.superTypes.contains(Procedure) -»
	 		«IF isRunnable(((Procedure)this).executable,this) -»
	 			«EXPAND Method::defaultProcedure FOR (Procedure)this -»
	 		«ELSEIF isCallable(((Procedure)this).executable,this) -»
	 			«EXPAND Method::callableProcedure FOR (Procedure)this -»
	 		«ELSEIF ((Procedure)this).executable.length == null || ((Procedure)this).executable.length == 0-»
	 			«EXPAND Method::noopProcedure FOR (Procedure)this -»
		 	«ELSE-»
				«EXPAND Method::defaultProcedure FOR (Procedure)this -»
	 		«ENDIF-»
		«ENDIF-»
	«ENDIF-»	 
«ENDDEFINE»

«DEFINE defaultProcedure FOR Procedure»

	/**
	 * Entry method of procedure «this.getElementName()».
	 * This procedure is bound to «this.executable»
	 * Description : «this.description»
	 * @generated «getGeneratorRawNameStr()»
	 */
	 «EXPAND Annotation::generatedWithHashToBeComputed FOR this»
	 «EXPAND Annotation::join FOR this»
	 «IF this.metaType == WhileLoop -»
		«EXPAND Annotation::whileLoop FOR (WhileLoop)this»
		«EXPAND Annotation::capacity FOR this»
	«ELSEIF this.metaType == ForEachLoop -»
		«EXPAND Annotation::capacity FOR this»
	«ENDIF-»
	 public «this.executable» «this.getElementName()»(«IF this.metaType == ForEachLoop -»«EXPAND Annotation::forEach FOR (ForEachLoop)this -»«ENDIF-») {
	 	// TODO : to be implemented
	 	
	 	return new «this.executable»();
	 }
	 
	/**
	 * Exit method of procedure «this.getElementName()».
	 * This procedure is bound to «this.executable»
	 * Description : «this.description»
	 * @generated «getGeneratorRawNameStr()»
	 */
	 «EXPAND Annotation::generatedWithHashToBeComputed FOR this»
	 «EXPAND Annotation::split FOR this»
	 public void «this.getElementName()»(«this.executable» executable) {
	 	// TODO : to be implemented
	 	
	 }
«ENDDEFINE»

«DEFINE callableProcedure FOR Procedure»

	/**
	 * Entry method of procedure «this.getElementName()».
	 * This procedure is bound to «this.executable»
	 * Description : «this.description»
	 * @generated «getGeneratorRawNameStr()»
	 */
	 «EXPAND Annotation::generatedWithHashToBeComputed FOR this»
	 «EXPAND Annotation::join FOR this»
	 «IF this.metaType == WhileLoop -»
		«EXPAND Annotation::whileLoop FOR (WhileLoop)this»
		«EXPAND Annotation::capacity FOR this»
	«ELSEIF this.metaType == ForEachLoop -»
		«EXPAND Annotation::capacity FOR this»
	«ENDIF-»
	 public «this.executable» «this.getElementName()»(«IF this.metaType == ForEachLoop -»«EXPAND Annotation::forEach FOR (ForEachLoop)this -»«ENDIF-») {
	 	// TODO : to be implemented
	 	
	 	return new «this.executable»();
	 }

	/**
	 * Exit method of procedure  «this.getElementName()».
	 * This procedure is bound to «this.executable»
	 * Description : «this.description»
	 * @generated «getGeneratorRawNameStr()»
	 */
	 «EXPAND Annotation::generatedWithHashToBeComputed FOR this»
	 «EXPAND Annotation::split FOR this»
	 public void «this.getElementName()»(«this.executable» executable, «getCallableGeneric(this.executable,this)» result){
	 	// TODO : to be implemented
	 	
	 }
«ENDDEFINE»

«DEFINE handler FOR Handler»
	/**
	 * Handler «this.getElementName()»
	 * Description : «this.description»
	 * @generated «getGeneratorRawNameStr()»
	 */
	 «EXPAND Annotation::generatedWithHashToBeComputed FOR this»
	 «EXPAND Annotation::handler FOR this»
	 «EXPAND Annotation::split FOR this»
	 public void «this.getElementName()» (java.lang.Exception e) {
	 	// TODO : to be implemented
	 	
	 }

«ENDDEFINE»

«DEFINE pipeline FOR Pipeline»

	/**
	 * Entry method of Pipeline «this.getElementName()».
	 * Description : «this.description»
	 * @generated «getGeneratorRawNameStr()»
	 */
	 «EXPAND Annotation::generatedWithHashToBeComputed FOR this»
	 «EXPAND Annotation::join FOR this»
	 «EXPAND Annotation::capacity FOR this»
	 public «this.getElementName().toFirstUpper()»Class «this.getElementName()»(«EXPAND Annotation::pipelineParameter FOR (Pipeline)this -») {
	 	// TODO : to be implemented
	 	
	 	return new «this.getElementName().toFirstUpper()»Class(«this.iterable.name»);
	 }
	 
	/**
	 * Exit method of pipeline «this.getElementName()».
	 * Description : «this.description»
	 * @generated «getGeneratorRawNameStr()»
	 */
	 «EXPAND Annotation::generatedWithHashToBeComputed FOR this»
	 «EXPAND Annotation::split FOR this»
	 public void «this.getElementName()»(«this.getElementName().toFirstUpper()»Class executable) {
	 	// TODO : to be implemented
	 	
	 }
	 
	/**
	 * Inner class for Pipeline «this.name»
	 * Description : «this.description»	
	 **/
	 «EXPAND Annotation::pipelineClass FOR (Pipeline)this -»
	 «EXPAND Annotation::capacity FOR this»
	 public class «this.getElementName().toFirstUpper()»Class {
	 	
	 	/**
 		 * «this.name» field
 		 * Description : «this.description»	
 		 **/
	 	«EXPAND Annotation::pipelineData FOR (Pipeline)this -»
	 	«this.iterable.type» «this.iterable.name»;
	 	
	 	public «this.getElementName().toFirstUpper()»Class(«this.iterable.type» «this.iterable.name»){
	 		this.«this.iterable.name» = «this.iterable.name»;
	 	}
	 	
	 	«EXPAND Method::pipelineProcedure FOREACH this.procedures»
	 	
	   /**
	 	* Returns the «this.iterable.name» Data.
		* @return «this.iterable.type»
		*/
	 	«EXPAND Annotation::generatedWithHashToBeComputed FOR this»
	 	 public «this.iterable.type» get«this.iterable.name.toFirstUpper()»(){
	 		 return this.«this.iterable.name»;
	 	}
	 
	   /**
		* Sets the data «this.iterable.name.toFirstLower()»
		* @param <code>«this.iterable.type»</code> object.
		*/
		«EXPAND Annotation::generatedWithHashToBeComputed FOR this»
		public void set«this.iterable.name.toFirstUpper()»(«this.iterable.type» «this.iterable.name.toFirstLower()»){
	 		 this.«this.iterable.name»=«this.iterable.name.toFirstLower()»;
		}
	 }
«ENDDEFINE»

«DEFINE pipelineProcedure FOR Procedure»
	«IF isRunnable(((Procedure)this).executable,this) -»
		«EXPAND Method::defaultPipelineProcedure FOR (Procedure)this -»
	«ELSEIF isCallable(((Procedure)this).executable,this) -»
		«EXPAND Method::callablePipelineProcedure FOR (Procedure)this -»
	«ELSEIF ((Procedure)this).executable.length == null || ((Procedure)this).executable.length == 0-»
		«EXPAND Method::noopPipelineProcedure FOR (Procedure)this -»
	«ENDIF-»
«ENDDEFINE»

«DEFINE defaultPipelineProcedure FOR Procedure»

	/**
	 * Entry method of procedure «this.getElementName()».
	 * This procedure is bound to «this.executable»
	 * Description : «this.description»
	 * @generated «getGeneratorRawNameStr()»
	 */
	 «EXPAND Annotation::generatedWithHashToBeComputed FOR this»
	 «EXPAND Annotation::pipelineProcedureJoin FOR this»
	 «EXPAND Annotation::capacity FOR this»
	 public «this.executable» «this.getElementName()»(Object next) {
	 	// TODO : to be implemented
	 	
	 	return new «this.executable»();
	 }
	 
	/**
	 * Exit method of procedure «this.getElementName()».
	 * This procedure is bound to «this.executable»
	 * Description : «this.description»
	 * @generated «getGeneratorRawNameStr()»
	 */
	 «EXPAND Annotation::generatedWithHashToBeComputed FOR this»
	 «EXPAND Annotation::pipelineProcedureSplit FOR this»
	 public void «this.getElementName()»(«this.executable» executable) {
	 	// TODO : to be implemented
	 	
	 }
«ENDDEFINE»

«DEFINE callablePipelineProcedure FOR Procedure»

	/**
	 * Entry method of procedure «this.getElementName()».
	 * This procedure is bound to «this.executable»
	 * Description : «this.description»
	 * @generated «getGeneratorRawNameStr()»
	 */
	 «EXPAND Annotation::generatedWithHashToBeComputed FOR this»
	 «EXPAND Annotation::pipelineProcedureJoin FOR this»
	 «EXPAND Annotation::capacity FOR this»
	 public «this.executable» «this.getElementName()»(Object next) {
	 	// TODO : to be implemented
	 	
	 	return new «this.executable»();
	 }

	/**
	 * Exit method of procedure  «this.getElementName()».
	 * This procedure is bound to «this.executable»
	 * Description : «this.description»
	 * @generated «getGeneratorRawNameStr()»
	 */
	 «EXPAND Annotation::generatedWithHashToBeComputed FOR this»
	 «EXPAND Annotation::pipelineProcedureSplit FOR this»
	 public void «this.getElementName()»(«this.executable» executable, «getCallableGeneric(this.executable,this)» result){
	 	// TODO : to be implemented
	 	
	 }
«ENDDEFINE»

«DEFINE noopPipelineProcedure FOR Procedure»
	/**
	 * Noop Procedure «this.getElementName()».
	 * This procedure is not bound to an executable.
	 * Description : «this.description»
	 * @generated «getGeneratorRawNameStr()»
	 */
	 «EXPAND Annotation::generatedWithHashToBeComputed FOR this»
	 «EXPAND Annotation::pipelineProcedureJoin FOR this»
	 «EXPAND Annotation::pipelineProcedureSplit FOR this»
	 public void «this.getElementName()» (Object next){
	 	// TODO : to be implemented
	 	
	 }

«ENDDEFINE»


«DEFINE noopProcedure FOR Procedure»
	/**
	 * Noop Procedure «this.getElementName()».
	 * This procedure is not bound to an executable.
	 * Description : «this.description»
	 * @generated «getGeneratorRawNameStr()»
	 */
	 «EXPAND Annotation::generatedWithHashToBeComputed FOR this»
	 «EXPAND Annotation::join FOR this»
	 «EXPAND Annotation::split FOR this»
	 public void «this.getElementName()» (){
	 	// TODO : to be implemented
	 	
	 }

«ENDDEFINE»

«DEFINE predicate FOR Predicate»

	/**
	 * Predicate «this.getPredicateName()»
	 * Description : «this.description»
	 * @generated «getGeneratorRawNameStr()»
	 */
	 «EXPAND Annotation::generatedWithHashToBeComputed FOR this»
	 public boolean is«this.getPredicateName().toFirstUpper()» (){
	 	// TODO : to be implemented
	 	return false;
	 }

«ENDDEFINE»

«DEFINE dataType FOR Data»

	/**
	 * Returns the «this.name.toFirstLower()» Data.
	 * @return «this.type»
	 */
	 «EXPAND Annotation::generatedWithHashToBeComputed FOR this»
	 public «type» get«this.name.toFirstUpper()»(){
	 	return this.«this.name»;
	 }
	 
	 /**
	 * Sets the data «this.name.toFirstLower()»
	 * @param <code>«this.type»</code> object.
	 */
	 «EXPAND Annotation::generatedWithHashToBeComputed FOR this»
	 public void set«this.name.toFirstUpper()»(«this.type» «this.name.toFirstLower()»){
	 	this.«this.name»=«this.name.toFirstLower()»;
	 }

«ENDDEFINE»